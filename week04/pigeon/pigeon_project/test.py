import cv2
import numpy as np

# --- Configuration ---
# NOTE: Replace 'pigeon_image.jpg' with the actual path to your image file.
IMAGE_PATH = 'week04/dfg.png' 
DETECTION_LABEL = "Pigeon Body"

def detect_pigeon_body(image_path):
    """
    Loads an image, simulates the detection of a pigeon's body using a 
    pre-defined bounding box (BBox), and draws the result.

    In a real-world application, the core logic here (the BBox coordinates) 
    would be generated by a trained machine learning model (e.g., YOLO, R-CNN).
    """
    try:
        # 1. Load the image
        img = cv2.imread(image_path)
        
        if img is None:
            print(f"ERROR: Could not load image from path: {image_path}")
            print("Please ensure the file exists and is readable.")
            return

        # 2. Simulate the Object Detection Result
        # A real detection model would return a list of bounding boxes (BBoxes) 
        # and confidence scores. For this example, we use a single, mock BBox.
        
        # BBox format: [x_start, y_start, width, height]
        # These coordinates are arbitrary and just for demonstration purposes.
        # You would need to adjust these based on your actual image and where the pigeon is.
        # Example coordinates (simulating a detection result)
        if img.shape[0] > 100 and img.shape[1] > 100:
             # If the image is large enough, use a relative box in the center
            height, width, _ = img.shape
            # [x_min, y_min, x_max, y_max] in normalized coordinates (0 to 1)
            # Let's target the center 50% area
            mock_detections = [
                {'box': [int(width * 0.25), int(height * 0.25), int(width * 0.75), int(height * 0.75)], 'label': DETECTION_LABEL, 'confidence': 0.95}
            ]
        else:
             print("Image too small to display a meaningful bounding box.")
             return


        # 3. Draw Bounding Boxes and Labels
        for detection in mock_detections:
            # Extract box coordinates (x_min, y_min, x_max, y_max)
            x_min, y_min, x_max, y_max = detection['box']
            label = detection['label']
            confidence = detection['confidence']
            
            # Define colors and thickness
            color = (0, 255, 0)  # Green BBox
            thickness = 2
            font_scale = 0.7
            
            # Draw the rectangle (Bounding Box)
            cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color, thickness)
            
            # Prepare the label text
            text = f"{label}: {confidence:.2f}"
            
            # Get text size for background box
            (text_w, text_h), baseline = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, font_scale, thickness)
            
            # Draw background box for text
            cv2.rectangle(img, (x_min, y_min - text_h - baseline), (x_min + text_w, y_min), color, -1)
            
            # Put the text on the image
            cv2.putText(img, text, (x_min, y_min - baseline), cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 0, 0), thickness)
            
        # 4. Display the result
        window_name = 'Pigeon Detection Result'
        cv2.imshow(window_name, img)
        
        # Wait for a key press and close the window
        print("Detection complete. Press any key to close the image window.")
        cv2.waitKey(0)
        cv2.destroyAllWindows()
        
    except Exception as e:
        print(f"An error occurred during processing: {e}")

if __name__ == "__main__":
    # --- Instructions for the user ---
    # 1. Save an image of a pigeon as 'pigeon_image.jpg' in the same directory as this script.
    # 2. To use real detection, you would replace the 'mock_detections' logic with
    #    a call to a trained model (like a TensorFlow, PyTorch, or Ultralytics YOLO model).
    
    detect_pigeon_body(IMAGE_PATH)
